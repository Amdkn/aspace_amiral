name: PR Integration Agent

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
    branches: [main, develop]

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write

jobs:
  # Job 1: Validate PR rules
  validate-pr-rules:
    name: Validate PR Rules
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check PR target branch
        id: check-target
        run: |
          TARGET_BRANCH="${{ github.base_ref }}"
          SOURCE_BRANCH="${{ github.head_ref }}"
          
          echo "Target branch: $TARGET_BRANCH"
          echo "Source branch: $SOURCE_BRANCH"
          
          # Rule: No direct PRs to main (only from develop or hotfix branches)
          if [[ "$TARGET_BRANCH" == "main" ]]; then
            if [[ ! "$SOURCE_BRANCH" =~ ^(develop|hotfix/.*|release/.*)$ ]]; then
              echo "::error::Direct PRs to 'main' are not allowed. Please target 'develop' instead, or use hotfix/release branches."
              exit 1
            fi
          fi
          
          echo "‚úÖ Branch policy validated"

      - name: Validate commit messages
        run: |
          echo "Checking commit messages..."
          COMMITS=$(git log --format=%s origin/${{ github.base_ref }}..HEAD)
          
          # Check for conventional commits pattern
          INVALID_COMMITS=""
          while IFS= read -r commit; do
            if [[ ! "$commit" =~ ^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?:.+ ]]; then
              INVALID_COMMITS="$INVALID_COMMITS\n- $commit"
            fi
          done <<< "$COMMITS"
          
          if [[ -n "$INVALID_COMMITS" ]]; then
            echo "::warning::Some commits don't follow conventional commit format:"
            echo -e "$INVALID_COMMITS"
            echo "::warning::Please use format: type(scope): description"
            echo "::warning::Types: feat, fix, docs, style, refactor, test, chore, perf, ci, build, revert"
          else
            echo "‚úÖ All commits follow conventional commit format"
          fi

      - name: Check for merge conflicts
        run: |
          echo "Checking for merge conflicts..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Attempt merge simulation
          git fetch origin ${{ github.base_ref }}
          if git merge-tree $(git merge-base HEAD origin/${{ github.base_ref }}) origin/${{ github.base_ref }} HEAD | grep -q "<<<<<<< "; then
            echo "::error::Merge conflicts detected. Please resolve conflicts before merging."
            exit 1
          else
            echo "‚úÖ No merge conflicts detected"
          fi

  # Job 2: Code quality checks
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pylint flake8 black isort pytest pytest-cov
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Python linting with pylint
        continue-on-error: true
        run: |
          echo "Running pylint..."
          PYTHON_FILES=$(find . -name "*.py" -not -path "*/.*" -not -path "*/venv/*" -not -path "*/node_modules/*" | tr '\n' ' ')
          if [ -n "$PYTHON_FILES" ]; then
            pylint $PYTHON_FILES --exit-zero --output-format=text | tee pylint-report.txt
            echo "‚úÖ Pylint check complete"
          else
            echo "No Python files found"
          fi

      - name: Python style check with flake8
        continue-on-error: true
        run: |
          echo "Running flake8..."
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude=venv,node_modules,.git
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics --exclude=venv,node_modules,.git

      - name: Check Python code formatting with black
        continue-on-error: true
        run: |
          echo "Checking Python formatting with black..."
          black --check --diff . --exclude="venv|node_modules|\.git"

      - name: Check Python imports with isort
        continue-on-error: true
        run: |
          echo "Checking Python imports with isort..."
          isort --check-only --diff . --skip venv --skip node_modules --skip .git

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: JavaScript/TypeScript linting
        continue-on-error: true
        run: |
          echo "Checking for JavaScript/TypeScript files..."
          JS_DIRS=$(find . -name "package.json" -not -path "*/node_modules/*" -exec dirname {} \;)
          
          for dir in $JS_DIRS; do
            echo "Processing $dir..."
            cd $dir
            if [ -f "package.json" ]; then
              echo "Installing dependencies..."
              npm install || true
              
              # Run linting if configured
              if grep -q '"lint"' package.json; then
                echo "Running linter..."
                npm run lint || echo "::warning::Linting failed in $dir"
              fi
            fi
            cd - > /dev/null
          done

      - name: SQL file validation
        continue-on-error: true
        run: |
          echo "Validating SQL files..."
          SQL_FILES=$(find . -name "*.sql" -not -path "*/.*" -not -path "*/node_modules/*")
          
          if [ -n "$SQL_FILES" ]; then
            echo "Found SQL files:"
            echo "$SQL_FILES"
            
            # Basic SQL syntax check (check for common errors)
            for file in $SQL_FILES; do
              echo "Checking $file..."
              
              # Check for basic SQL syntax issues
              if grep -i "select.*from.*where.*=" "$file" | grep -v " = " > /dev/null; then
                echo "::warning::Possible SQL syntax issue in $file"
              fi
              
              # Check for potential SQL injection patterns (basic check)
              if grep -E "EXEC\s*\(|EXECUTE\s*\(" "$file" > /dev/null; then
                echo "::warning::Dynamic SQL detected in $file - review for security"
              fi
            done
            echo "‚úÖ SQL validation complete"
          else
            echo "No SQL files found"
          fi

  # Job 3: Run tests with coverage
  test-with-coverage:
    name: Run Tests with Coverage
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Create KPI file structure
        run: |
          mkdir -p 03_RESOURCES/05_TEMPLATES
          echo '{"pulses": []}' > 03_RESOURCES/05_TEMPLATES/business_kpi.json

      - name: Run Python tests with coverage
        run: |
          echo "Running Python tests..."
          
          # Find test files
          TEST_FILES=$(find . -name "test_*.py" -o -name "*_test.py" | grep -v node_modules | grep -v venv)
          
          if [ -n "$TEST_FILES" ]; then
            # Run existing verification scripts
            python verify_phase_1.py || echo "Phase 1 verification skipped"
            python verify_phase_2.py || echo "Phase 2 verification skipped"
            
            # Run pytest with coverage
            pytest --cov=. --cov-report=term --cov-report=html --cov-report=xml || echo "::warning::Some tests failed"
            
            # Display coverage summary
            coverage report || true
          else
            echo "No Python test files found"
          fi

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        if: always()
        continue-on-error: true
        with:
          files: ./coverage.xml
          flags: unittests
          name: codecov-umbrella

      - name: Comment coverage on PR
        if: always()
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let coverageComment = '## üìä Test Coverage Report\n\n';
            
            try {
              // Try to read coverage report
              const coverage = 'Coverage report generated. Check the Codecov link above for details.';
              coverageComment += coverage;
            } catch (error) {
              coverageComment += 'Coverage data not available.';
            }
            
            // Add comment to PR
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: coverageComment
            });

  # Job 4: Label management
  manage-labels:
    name: Manage PR Labels
    runs-on: ubuntu-latest
    needs: [validate-pr-rules, code-quality, test-with-coverage]
    if: always()
    steps:
      - name: Add labels based on PR status
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Get PR details
            const pr = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber
            });
            
            // Get job results - handle potential errors gracefully
            let runsResponse;
            try {
              runsResponse = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                per_page: 5
              });
            } catch (error) {
              console.log('Could not fetch workflow runs:', error.message);
            }
            
            const labels = [];
            
            // Add labels based on checks
            const jobs = await github.rest.actions.listJobsForWorkflowRun({
              owner,
              repo,
              run_id: context.runId
            });
            
            let hasFailures = false;
            let hasWarnings = false;
            
            for (const job of jobs.data.jobs) {
              if (job.conclusion === 'failure') {
                hasFailures = true;
              }
              if (job.conclusion === 'success' && job.name.includes('quality')) {
                // Check for warnings in logs
                labels.push('quality-checked');
              }
            }
            
            if (hasFailures) {
              labels.push('needs-fixes');
            } else {
              labels.push('ready-for-review');
            }
            
            // Add size label based on changes
            const files = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number: prNumber
            });
            
            const additions = pr.data.additions;
            const deletions = pr.data.deletions;
            const totalChanges = additions + deletions;
            
            if (totalChanges < 10) {
              labels.push('size/XS');
            } else if (totalChanges < 50) {
              labels.push('size/S');
            } else if (totalChanges < 200) {
              labels.push('size/M');
            } else if (totalChanges < 500) {
              labels.push('size/L');
            } else {
              labels.push('size/XL');
            }
            
            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels
              });
            }

  # Job 5: PR summary report
  pr-summary:
    name: Generate PR Summary
    runs-on: ubuntu-latest
    needs: [validate-pr-rules, code-quality, test-with-coverage]
    if: always()
    steps:
      - name: Generate and post summary
        uses: actions/github-script@v7
        with:
          script: |
            const branchRulesStatus = '${{ needs.validate-pr-rules.result }}';
            const codeQualityStatus = '${{ needs.code-quality.result }}';
            const testsStatus = '${{ needs.test-with-coverage.result }}';
            
            let branchRulesIcon = branchRulesStatus === 'success' ? '‚úÖ Passed' : '‚ùå Failed';
            let codeQualityIcon = codeQualityStatus === 'success' ? '‚úÖ Passed' : (codeQualityStatus === 'skipped' ? '‚è≠Ô∏è Skipped' : '‚ö†Ô∏è Issues Found');
            let testsIcon = testsStatus === 'success' ? '‚úÖ Passed' : (testsStatus === 'skipped' ? '‚è≠Ô∏è Skipped' : '‚ùå Failed');
            
            let allPassed = branchRulesStatus === 'success' && codeQualityStatus === 'success' && testsStatus === 'success';
            let nextSteps = allPassed ? '‚úÖ All checks passed! This PR is ready for review.' : '‚ö†Ô∏è Some checks require attention. Please review the failures above.';
            
            const summary = `
            ## ü§ñ PR Integration Agent Report
            
            ### ‚úÖ Validation Results
            
            | Check | Status |
            |-------|--------|
            | Branch Rules | ${branchRulesIcon} |
            | Code Quality | ${codeQualityIcon} |
            | Tests | ${testsIcon} |
            
            ### üìã Next Steps
            
            ${nextSteps}
            
            ---
            *This is an automated report from the PR Integration Agent*
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
